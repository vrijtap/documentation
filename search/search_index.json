{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VrijTap Project Vrijtap aims to create a machine that automatically fills your glass with beer. With our machine we are trying to make ordering easy for the customers, keeping track of consumption and storage easy for the owner and wastage low by using sensors / AI. [A picture of the system will be displayed here when we started working on a prototype]","title":"Home"},{"location":"#vrijtap","text":"Project Vrijtap aims to create a machine that automatically fills your glass with beer. With our machine we are trying to make ordering easy for the customers, keeping track of consumption and storage easy for the owner and wastage low by using sensors / AI. [A picture of the system will be displayed here when we started working on a prototype]","title":"VrijTap"},{"location":"manual/","text":"Vrijtap Project Manual Table of Contents Vrijtap Project Manual Table of Contents 1. Introduction Purpose and Goals Project Overview 2. Getting Started Prerequisites Installation Instructions Configuration 3. User Guide User Roles and Permissions User Registration and Login Main Features How to Use [Specific Feature] 4. Developer Guide Architecture Overview Technology Stack Data Model APIs and Endpoints Coding Guidelines Version Control Local Development Setup Deployment Instructions 5. Testing and Quality Assurance Test Cases and Scenarios Testing Procedures Known Issues and Limitations 6. Monitoring and Analytics Key Performance Indicators (KPIs) Analytics Tools Used Data Privacy and Security 7. Support and Feedback Contact Information Support Channels How to Report Bugs or Issues Feedback Mechanisms 8. Legal and Compliance Privacy Policy Data Handling Policies Compliance Requirements 9. Maintenance and Roadmap Maintenance Plan Future Updates and Features Product Roadmap 10. Glossary 11. Acknowledgments 12. Version History 1. Introduction 1. Introduction Purpose and Goals The Vrijtap project is centered around a novel and practical solution - an automatic beer tap designed to pour beer with the perfect foam layer consistently. This innovative project addresses a common challenge faced by both consumers and businesses: the art of pouring the ideal beer. Project Significance Pouring a beer can often be a challenging task, requiring skill and precision to achieve the desired taste and presentation. Inefficient pouring can result in wasted beer and food resources, contributing to unnecessary food waste. The Vrijtap project seeks to eliminate these issues by providing a reliable and user-friendly solution for consistently pouring beer with the perfect foam layer. Project Goals Our primary goals for the Vrijtap project include: Precision : Developing a system that accurately measures and pours the right amount of beer with the ideal foam layer. Ease of Use : Creating a user-friendly interface to ensure that anyone, regardless of experience, can operate the beer tap with confidence. Resource Efficiency : Reducing beer and food wastage, ultimately contributing to a more sustainable and environmentally friendly beverage-serving experience. By achieving these goals, the Vrijtap project aims to revolutionize the way beer is served, making it not only more enjoyable but also more responsible and sustainable. Project Overview 2. Project Overview Scope The Vrijtap project's scope encompasses the development of an automatic beer tap system that excels in pouring beer with consistent, perfect foam layers. This includes the design, engineering, and implementation of hardware and software components necessary for its operation. Target Audience The Vrijtap project is primarily designed to cater to: Bars and Restaurants : Providing an efficient and consistent beer pouring solution that enhances customer satisfaction and minimizes wastage. Beer Enthusiasts : Offering a home-use version for beer connoisseurs who seek the perfect pour in the comfort of their own homes. Event Organizers : Facilitating large-scale events by simplifying beer service and minimizing the expertise required for bartenders. Unique Features and Innovations Vrijtap sets itself apart from traditional beer pouring methods with several unique features and innovations, including: Precision Pouring : Utilizing advanced sensors and algorithms to precisely measure and dispense beer, ensuring every pour has the ideal foam layer. User-Friendly Interface : Incorporating an intuitive interface that allows users to easily adjust pouring settings and monitor the pouring process. Sustainability Focus : Promoting environmental responsibility by reducing beer and food wastage, aligning with the growing demand for sustainable practices. Data Analytics : Collecting data on pouring patterns and user preferences, which can be used to optimize beer quality and user experience. Customization Options : Allowing users to tailor their beer pouring experience by choosing the level of foam and beer temperature. These unique features and innovations position Vrijtap as a groundbreaking solution in the world of beverage service, offering a perfect pour with every glass and contributing to more responsible and enjoyable beer consumption. 2. Getting Started Prerequisites Before using or developing for Vrijtap , please ensure that you meet the following prerequisites: Hardware Requirements Automatic Beer Tap System : To use the Vrijtap system, you'll need the physical automatic beer tap device, including its components. Computer or Mobile Device : A computer or mobile device with internet connectivity for configuration and monitoring purposes. Power Supply : Ensure a stable power supply for the automatic beer tap system. Software Requirements Operating System : Any modern operating system compatible with the configuration software provided for Vrijtap. Common options include Windows, macOS, and Linux distributions. Internet Browser : A web browser to access the interface, preferably the latest versions of popular browsers such as Chrome, Firefox, or Safari. Skills and Knowledge Technical Aptitude : Basic technical knowledge to set up and configure the automatic beer tap system using the provided software. User Experience (UX) : Familiarity with the user interface to operate the system. Maintenance Skills : Basic troubleshooting and maintenance skills to ensure the proper functioning of the Vrijtap system. Meeting these prerequisites will ensure a smooth experience when using or developing for Vrijtap, whether you are a user or a developer working with the system. Installation Instructions Provide step-by-step installation instructions for Vrijtap. Include system requirements and dependencies. Configuration Explain any important configuration settings or options for users or developers. 3. User Guide User Roles and Permissions Describe the different user roles in Vrijtap and their permissions. User Registration and Login Explain how users can register for accounts and log in to Vrijtap. Main Features List and briefly describe the main features of Vrijtap. How to Use [Specific Feature] Provide detailed instructions on using specific features, if applicable. 4. Developer Guide Architecture Overview Outline the high-level architecture of Vrijtap, including key components and interactions. Technology Stack List the technologies and tools used in developing Vrijtap. Data Model Describe the data model, including tables, relationships, and constraints. APIs and Endpoints Document the APIs and endpoints, including request/response formats and authentication methods. Coding Guidelines Provide coding guidelines and best practices for developers working on Vrijtap. Version Control Explain version control management, including branching and release processes. Local Development Setup Give instructions for setting up a local development environment for Vrijtap. Deployment Instructions Explain how to deploy Vrijtap to a production environment, including configuration settings and best practices. 5. Testing and Quality Assurance Test Cases and Scenarios Provide a list of test cases and scenarios to cover during testing. Testing Procedures Explain testing procedures, including how to run tests and report issues. Known Issues and Limitations List any known bugs, issues, or limitations in Vrijtap. 6. Monitoring and Analytics Key Performance Indicators (KPIs) Outline the KPIs monitored in the production environment. Analytics Tools Used Mention analytics tools or services used for user behavior tracking and insights. Data Privacy and Security Explain measures for data privacy and security. 7. Support and Feedback Contact Information Provide contact information for reaching the Vrijtap team. Support Channels List support channels, such as email, chat, or a support portal. How to Report Bugs or Issues Explain how users can report bugs or issues encountered while using Vrijtap. Feedback Mechanisms Describe how users can provide feedback or suggestions for improving Vrijtap. 8. Legal and Compliance Privacy Policy Link to or provide the privacy policy regarding user data handling. Data Handling Policies Explain how user data is stored, processed, and protected. Compliance Requirements Mention legal or industry-specific compliance requirements for Vrijtap. 9. Maintenance and Roadmap Maintenance Plan Discuss post-launch maintenance and support plans. Future Updates and Features Share insights into planned features and updates for Vrijtap. Product Roadmap Provide a long-term vision and goals for Vrijtap. 10. Glossary Include a glossary of terms and acronyms for user understanding. 11. Acknowledgments Give credit and acknowledgment to third-party tools, libraries, or resources used in developing Vrijtap. 12. Version History Version 1.0.0 - the first manual This streamlined markdown template provides a clear structure for your Vrijtap project documentation.","title":"Manual"},{"location":"manual/#vrijtap-project-manual","text":"","title":"Vrijtap Project Manual"},{"location":"manual/#table-of-contents","text":"Vrijtap Project Manual Table of Contents 1. Introduction Purpose and Goals Project Overview 2. Getting Started Prerequisites Installation Instructions Configuration 3. User Guide User Roles and Permissions User Registration and Login Main Features How to Use [Specific Feature] 4. Developer Guide Architecture Overview Technology Stack Data Model APIs and Endpoints Coding Guidelines Version Control Local Development Setup Deployment Instructions 5. Testing and Quality Assurance Test Cases and Scenarios Testing Procedures Known Issues and Limitations 6. Monitoring and Analytics Key Performance Indicators (KPIs) Analytics Tools Used Data Privacy and Security 7. Support and Feedback Contact Information Support Channels How to Report Bugs or Issues Feedback Mechanisms 8. Legal and Compliance Privacy Policy Data Handling Policies Compliance Requirements 9. Maintenance and Roadmap Maintenance Plan Future Updates and Features Product Roadmap 10. Glossary 11. Acknowledgments 12. Version History","title":"Table of Contents"},{"location":"manual/#1-introduction","text":"","title":"1. Introduction"},{"location":"manual/#1-introduction_1","text":"","title":"1. Introduction"},{"location":"manual/#purpose-and-goals","text":"The Vrijtap project is centered around a novel and practical solution - an automatic beer tap designed to pour beer with the perfect foam layer consistently. This innovative project addresses a common challenge faced by both consumers and businesses: the art of pouring the ideal beer.","title":"Purpose and Goals"},{"location":"manual/#project-significance","text":"Pouring a beer can often be a challenging task, requiring skill and precision to achieve the desired taste and presentation. Inefficient pouring can result in wasted beer and food resources, contributing to unnecessary food waste. The Vrijtap project seeks to eliminate these issues by providing a reliable and user-friendly solution for consistently pouring beer with the perfect foam layer.","title":"Project Significance"},{"location":"manual/#project-goals","text":"Our primary goals for the Vrijtap project include: Precision : Developing a system that accurately measures and pours the right amount of beer with the ideal foam layer. Ease of Use : Creating a user-friendly interface to ensure that anyone, regardless of experience, can operate the beer tap with confidence. Resource Efficiency : Reducing beer and food wastage, ultimately contributing to a more sustainable and environmentally friendly beverage-serving experience. By achieving these goals, the Vrijtap project aims to revolutionize the way beer is served, making it not only more enjoyable but also more responsible and sustainable.","title":"Project Goals"},{"location":"manual/#project-overview","text":"","title":"Project Overview"},{"location":"manual/#2-project-overview","text":"","title":"2. Project Overview"},{"location":"manual/#scope","text":"The Vrijtap project's scope encompasses the development of an automatic beer tap system that excels in pouring beer with consistent, perfect foam layers. This includes the design, engineering, and implementation of hardware and software components necessary for its operation.","title":"Scope"},{"location":"manual/#target-audience","text":"The Vrijtap project is primarily designed to cater to: Bars and Restaurants : Providing an efficient and consistent beer pouring solution that enhances customer satisfaction and minimizes wastage. Beer Enthusiasts : Offering a home-use version for beer connoisseurs who seek the perfect pour in the comfort of their own homes. Event Organizers : Facilitating large-scale events by simplifying beer service and minimizing the expertise required for bartenders.","title":"Target Audience"},{"location":"manual/#unique-features-and-innovations","text":"Vrijtap sets itself apart from traditional beer pouring methods with several unique features and innovations, including: Precision Pouring : Utilizing advanced sensors and algorithms to precisely measure and dispense beer, ensuring every pour has the ideal foam layer. User-Friendly Interface : Incorporating an intuitive interface that allows users to easily adjust pouring settings and monitor the pouring process. Sustainability Focus : Promoting environmental responsibility by reducing beer and food wastage, aligning with the growing demand for sustainable practices. Data Analytics : Collecting data on pouring patterns and user preferences, which can be used to optimize beer quality and user experience. Customization Options : Allowing users to tailor their beer pouring experience by choosing the level of foam and beer temperature. These unique features and innovations position Vrijtap as a groundbreaking solution in the world of beverage service, offering a perfect pour with every glass and contributing to more responsible and enjoyable beer consumption.","title":"Unique Features and Innovations"},{"location":"manual/#2-getting-started","text":"","title":"2. Getting Started"},{"location":"manual/#prerequisites","text":"Before using or developing for Vrijtap , please ensure that you meet the following prerequisites:","title":"Prerequisites"},{"location":"manual/#hardware-requirements","text":"Automatic Beer Tap System : To use the Vrijtap system, you'll need the physical automatic beer tap device, including its components. Computer or Mobile Device : A computer or mobile device with internet connectivity for configuration and monitoring purposes. Power Supply : Ensure a stable power supply for the automatic beer tap system.","title":"Hardware Requirements"},{"location":"manual/#software-requirements","text":"Operating System : Any modern operating system compatible with the configuration software provided for Vrijtap. Common options include Windows, macOS, and Linux distributions. Internet Browser : A web browser to access the interface, preferably the latest versions of popular browsers such as Chrome, Firefox, or Safari.","title":"Software Requirements"},{"location":"manual/#skills-and-knowledge","text":"Technical Aptitude : Basic technical knowledge to set up and configure the automatic beer tap system using the provided software. User Experience (UX) : Familiarity with the user interface to operate the system. Maintenance Skills : Basic troubleshooting and maintenance skills to ensure the proper functioning of the Vrijtap system. Meeting these prerequisites will ensure a smooth experience when using or developing for Vrijtap, whether you are a user or a developer working with the system.","title":"Skills and Knowledge"},{"location":"manual/#installation-instructions","text":"Provide step-by-step installation instructions for Vrijtap. Include system requirements and dependencies.","title":"Installation Instructions"},{"location":"manual/#configuration","text":"Explain any important configuration settings or options for users or developers.","title":"Configuration"},{"location":"manual/#3-user-guide","text":"","title":"3. User Guide"},{"location":"manual/#user-roles-and-permissions","text":"Describe the different user roles in Vrijtap and their permissions.","title":"User Roles and Permissions"},{"location":"manual/#user-registration-and-login","text":"Explain how users can register for accounts and log in to Vrijtap.","title":"User Registration and Login"},{"location":"manual/#main-features","text":"List and briefly describe the main features of Vrijtap.","title":"Main Features"},{"location":"manual/#how-to-use-specific-feature","text":"Provide detailed instructions on using specific features, if applicable.","title":"How to Use [Specific Feature]"},{"location":"manual/#4-developer-guide","text":"","title":"4. Developer Guide"},{"location":"manual/#architecture-overview","text":"Outline the high-level architecture of Vrijtap, including key components and interactions.","title":"Architecture Overview"},{"location":"manual/#technology-stack","text":"List the technologies and tools used in developing Vrijtap.","title":"Technology Stack"},{"location":"manual/#data-model","text":"Describe the data model, including tables, relationships, and constraints.","title":"Data Model"},{"location":"manual/#apis-and-endpoints","text":"Document the APIs and endpoints, including request/response formats and authentication methods.","title":"APIs and Endpoints"},{"location":"manual/#coding-guidelines","text":"Provide coding guidelines and best practices for developers working on Vrijtap.","title":"Coding Guidelines"},{"location":"manual/#version-control","text":"Explain version control management, including branching and release processes.","title":"Version Control"},{"location":"manual/#local-development-setup","text":"Give instructions for setting up a local development environment for Vrijtap.","title":"Local Development Setup"},{"location":"manual/#deployment-instructions","text":"Explain how to deploy Vrijtap to a production environment, including configuration settings and best practices.","title":"Deployment Instructions"},{"location":"manual/#5-testing-and-quality-assurance","text":"","title":"5. Testing and Quality Assurance"},{"location":"manual/#test-cases-and-scenarios","text":"Provide a list of test cases and scenarios to cover during testing.","title":"Test Cases and Scenarios"},{"location":"manual/#testing-procedures","text":"Explain testing procedures, including how to run tests and report issues.","title":"Testing Procedures"},{"location":"manual/#known-issues-and-limitations","text":"List any known bugs, issues, or limitations in Vrijtap.","title":"Known Issues and Limitations"},{"location":"manual/#6-monitoring-and-analytics","text":"","title":"6. Monitoring and Analytics"},{"location":"manual/#key-performance-indicators-kpis","text":"Outline the KPIs monitored in the production environment.","title":"Key Performance Indicators (KPIs)"},{"location":"manual/#analytics-tools-used","text":"Mention analytics tools or services used for user behavior tracking and insights.","title":"Analytics Tools Used"},{"location":"manual/#data-privacy-and-security","text":"Explain measures for data privacy and security.","title":"Data Privacy and Security"},{"location":"manual/#7-support-and-feedback","text":"","title":"7. Support and Feedback"},{"location":"manual/#contact-information","text":"Provide contact information for reaching the Vrijtap team.","title":"Contact Information"},{"location":"manual/#support-channels","text":"List support channels, such as email, chat, or a support portal.","title":"Support Channels"},{"location":"manual/#how-to-report-bugs-or-issues","text":"Explain how users can report bugs or issues encountered while using Vrijtap.","title":"How to Report Bugs or Issues"},{"location":"manual/#feedback-mechanisms","text":"Describe how users can provide feedback or suggestions for improving Vrijtap.","title":"Feedback Mechanisms"},{"location":"manual/#8-legal-and-compliance","text":"","title":"8. Legal and Compliance"},{"location":"manual/#privacy-policy","text":"Link to or provide the privacy policy regarding user data handling.","title":"Privacy Policy"},{"location":"manual/#data-handling-policies","text":"Explain how user data is stored, processed, and protected.","title":"Data Handling Policies"},{"location":"manual/#compliance-requirements","text":"Mention legal or industry-specific compliance requirements for Vrijtap.","title":"Compliance Requirements"},{"location":"manual/#9-maintenance-and-roadmap","text":"","title":"9. Maintenance and Roadmap"},{"location":"manual/#maintenance-plan","text":"Discuss post-launch maintenance and support plans.","title":"Maintenance Plan"},{"location":"manual/#future-updates-and-features","text":"Share insights into planned features and updates for Vrijtap.","title":"Future Updates and Features"},{"location":"manual/#product-roadmap","text":"Provide a long-term vision and goals for Vrijtap.","title":"Product Roadmap"},{"location":"manual/#10-glossary","text":"Include a glossary of terms and acronyms for user understanding.","title":"10. Glossary"},{"location":"manual/#11-acknowledgments","text":"Give credit and acknowledgment to third-party tools, libraries, or resources used in developing Vrijtap.","title":"11. Acknowledgments"},{"location":"manual/#12-version-history","text":"Version 1.0.0 - the first manual This streamlined markdown template provides a clear structure for your Vrijtap project documentation.","title":"12. Version History"},{"location":"prototype/","text":"Prototype This page describes and shows all the physical connections of the circuits. The physical prototype and hardware are also shown in pictures with lables. Main circuit diagram The Vrijtap project contains actuators and sensors connected to a breadboard, Arduino Uno and RaspberryPi 4B+. These are shown in the diagram shown below:","title":"Prototype"},{"location":"prototype/#prototype","text":"This page describes and shows all the physical connections of the circuits. The physical prototype and hardware are also shown in pictures with lables.","title":"Prototype"},{"location":"prototype/#main-circuit-diagram","text":"The Vrijtap project contains actuators and sensors connected to a breadboard, Arduino Uno and RaspberryPi 4B+. These are shown in the diagram shown below:","title":"Main circuit diagram"},{"location":"arduino/circuit/","text":"Arduino Circuits In this project, the Arduino controlls the servo's, weight sensor and pump. The circuits will be described in this file. High Torque Servo In order to make the High Torque Servo work, you should at all times use an external power supply, as the 5V does not have enough amperage to power the High Torque Servo proficiently. This problem becomes even more critical when you attach multiple instances to the Arduino. For this reason, we are going to use a powerful power supply that provides as much 5V power amperage as needed for to make the servo's and pump function. The circuit for connecting a High Torque Servo is shown below. External Power Supply: Connect the positive (+) and negative (-) terminals of the external power supply to the corresponding terminals on the High Torque Servo. Signal Wire: Connect the signal wire from the High Torque Servo to a digital GPIO pin on the Arduino. Note that the Arduino and Servo will need to share a ground to the External Power Supply for the Arduino to be able to send signals. Power Supply to Arduino: Connect the external power supply to the Arduino. Pump In order to make the pump work, we are going to use a relais to switch the 12v power on/off. The circuit required for this ordeal is as follows: Scale The connections that are needed to read the loadcell are shown as following:","title":"Circuit"},{"location":"arduino/circuit/#arduino-circuits","text":"In this project, the Arduino controlls the servo's, weight sensor and pump. The circuits will be described in this file.","title":"Arduino Circuits"},{"location":"arduino/circuit/#high-torque-servo","text":"In order to make the High Torque Servo work, you should at all times use an external power supply, as the 5V does not have enough amperage to power the High Torque Servo proficiently. This problem becomes even more critical when you attach multiple instances to the Arduino. For this reason, we are going to use a powerful power supply that provides as much 5V power amperage as needed for to make the servo's and pump function. The circuit for connecting a High Torque Servo is shown below. External Power Supply: Connect the positive (+) and negative (-) terminals of the external power supply to the corresponding terminals on the High Torque Servo. Signal Wire: Connect the signal wire from the High Torque Servo to a digital GPIO pin on the Arduino. Note that the Arduino and Servo will need to share a ground to the External Power Supply for the Arduino to be able to send signals. Power Supply to Arduino: Connect the external power supply to the Arduino.","title":"High Torque Servo"},{"location":"arduino/circuit/#pump","text":"In order to make the pump work, we are going to use a relais to switch the 12v power on/off. The circuit required for this ordeal is as follows:","title":"Pump"},{"location":"arduino/circuit/#scale","text":"The connections that are needed to read the loadcell are shown as following:","title":"Scale"},{"location":"arduino/classes/","text":"Arduino Classes In this file, all of the classes made for the Arduino are discribed in terms of how to initialize them and use them. High Torque Servo The High Torque Servo is a servo meant for heavy loads. The Servo is powerful with the drawback of it consuming more power. The following functions can be used in our project to utilize it: HighTorqueServo(int minAngle, int maxAngle) Description: Creates an instance of the High Torque Servo class with specified angle limits. Parameters: minAngle : Minimum angle limit (accepted range: [0, 180]). maxAngle : Maximum angle limit (accepted range: [0, 180]). Example: #include \"HighTorqueServo.h\" // Initialize a High Torque Servo with angle limits HighTorqueServo myHighTorqueServo(0, 180); void init(uint8_t servoPin, float percentage) Description: Initialize the High Torque Servo. This function needs to be called in the setup function within the Arduino .ino file. Parameters: servoPin : Pin number for the servo. percentage : Initial percentage turned (accepted range: [0.0, 100.0]). Example: void setup() { myHighTorqueServo.init(6, 0.0); } void write(float percentage) Description: Turns the servo into a position based on the percentage of the minimum and maximum angle. Parameters: percentage : Percentage to turn to (accepted range: [0.0, 100.0]). Example: #include <Arduino.h> void loop() { delay(1000); myHighTorqueServo.write(100.0); } After performing all of the functions in the documentation you will succesfully initialize the servo with a resricted minimum and maximum angle and you will have moved it from 0 percent of that angle to 100 percent. This results in the Servo moving from 0 degrees to 180 degrees. StateMachine Overview The StateMachine class implements a state machine that manages transitions between SM_IDLE_STATE , SM_TAPPING_STATE , and SM_PAUSED_STATE based on specific events: SM_ZERO and SM_ONE . Constants SM_IDLE_STATE : Represents the idle state (value: 0). SM_TAPPING_STATE : Represents the tapping state (value: 1). SM_PAUSED_STATE : Represents the paused state (value: 2). SM_ZERO : Represents event zero. SM_ONE : Represents event one. Class Members Constructor StateMachine() Creates an instance of the StateMachine class with an initial state of SM_IDLE_STATE . Methods void handleInputEvent(int SM_event) Handles input events and manages state transitions. SM_event : The event triggering the state transition ( SM_ZERO or SM_ONE ). int getState() const Gets the current state of the StateMachine. Returns: int - The current state of the StateMachine. Usage Example #include \"StateMachine.h\" // Create a StateMachine instance StateMachine stateMachine; void setup() { stateMachine.handleInputEvent(SM_ONE); // Perform state transitions based on events } void loop() { int currentState = stateMachine.getState(); // Get the current state // Perform actions based on currentState } Loadcell Overview The arduino will make use of a loadcell to determine the percentage of liquids left in the tank. HighTorqueServo(int minAngle, int maxAngle) Description: Creates an instance of the High Torque Servo class with specified angle limits. Parameters: doutPin : pin used for digital output (desired: Digital pin 2). sckPin : pin used for sck (desired: Digital pin 3). Example: #include \"Scale.h\" // Constructor: Initializes the Scale object with specified pins and calibration factor Scale::Scale(int doutPin, int sckPin) : doutPin(doutPin), sckPin(sckPin) { } Methods void Scale::init() Sets up the scale and runs the reset function once to calibrate the scale to 0. The scale factor is also applied here. void Scale::reset() Uses the built in tare function to recalibrate the scale to 0. float Scale::getWeight() Returns the current weight of the tank in grams. Returns: float - The current weight of the tank. int Scale::getPercentage() Returns the current percentage of liquids in the tank. Returns: int - The current percentage. Usage Example #include \"Scale.h\" #include <Wire.h> const int LOADCELL_DOUT_PIN = 2; const int LOADCELL_SCK_PIN = 3; // Create a scale instance Scale scale(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN); void setup() { scale.init(); // initializes the scale } void loop() { int currentState = stateMachine.getState(); // Get the current state int percentage = scale.getPercentage(); // Get the percentage of the tank. }","title":"Classes"},{"location":"arduino/classes/#arduino-classes","text":"In this file, all of the classes made for the Arduino are discribed in terms of how to initialize them and use them.","title":"Arduino Classes"},{"location":"arduino/classes/#high-torque-servo","text":"The High Torque Servo is a servo meant for heavy loads. The Servo is powerful with the drawback of it consuming more power. The following functions can be used in our project to utilize it:","title":"High Torque Servo"},{"location":"arduino/classes/#hightorqueservoint-minangle-int-maxangle","text":"Description: Creates an instance of the High Torque Servo class with specified angle limits. Parameters: minAngle : Minimum angle limit (accepted range: [0, 180]). maxAngle : Maximum angle limit (accepted range: [0, 180]). Example: #include \"HighTorqueServo.h\" // Initialize a High Torque Servo with angle limits HighTorqueServo myHighTorqueServo(0, 180);","title":"HighTorqueServo(int minAngle, int maxAngle)"},{"location":"arduino/classes/#void-inituint8_t-servopin-float-percentage","text":"Description: Initialize the High Torque Servo. This function needs to be called in the setup function within the Arduino .ino file. Parameters: servoPin : Pin number for the servo. percentage : Initial percentage turned (accepted range: [0.0, 100.0]). Example: void setup() { myHighTorqueServo.init(6, 0.0); }","title":"void init(uint8_t servoPin, float percentage)"},{"location":"arduino/classes/#void-writefloat-percentage","text":"Description: Turns the servo into a position based on the percentage of the minimum and maximum angle. Parameters: percentage : Percentage to turn to (accepted range: [0.0, 100.0]). Example: #include <Arduino.h> void loop() { delay(1000); myHighTorqueServo.write(100.0); } After performing all of the functions in the documentation you will succesfully initialize the servo with a resricted minimum and maximum angle and you will have moved it from 0 percent of that angle to 100 percent. This results in the Servo moving from 0 degrees to 180 degrees.","title":"void write(float percentage)"},{"location":"arduino/classes/#statemachine","text":"","title":"StateMachine"},{"location":"arduino/classes/#overview","text":"The StateMachine class implements a state machine that manages transitions between SM_IDLE_STATE , SM_TAPPING_STATE , and SM_PAUSED_STATE based on specific events: SM_ZERO and SM_ONE .","title":"Overview"},{"location":"arduino/classes/#constants","text":"SM_IDLE_STATE : Represents the idle state (value: 0). SM_TAPPING_STATE : Represents the tapping state (value: 1). SM_PAUSED_STATE : Represents the paused state (value: 2). SM_ZERO : Represents event zero. SM_ONE : Represents event one.","title":"Constants"},{"location":"arduino/classes/#class-members","text":"","title":"Class Members"},{"location":"arduino/classes/#constructor","text":"","title":"Constructor"},{"location":"arduino/classes/#statemachine_1","text":"Creates an instance of the StateMachine class with an initial state of SM_IDLE_STATE .","title":"StateMachine()"},{"location":"arduino/classes/#methods","text":"","title":"Methods"},{"location":"arduino/classes/#void-handleinputeventint-sm_event","text":"Handles input events and manages state transitions. SM_event : The event triggering the state transition ( SM_ZERO or SM_ONE ).","title":"void handleInputEvent(int SM_event)"},{"location":"arduino/classes/#int-getstate-const","text":"Gets the current state of the StateMachine. Returns: int - The current state of the StateMachine.","title":"int getState() const"},{"location":"arduino/classes/#usage-example","text":"#include \"StateMachine.h\" // Create a StateMachine instance StateMachine stateMachine; void setup() { stateMachine.handleInputEvent(SM_ONE); // Perform state transitions based on events } void loop() { int currentState = stateMachine.getState(); // Get the current state // Perform actions based on currentState }","title":"Usage Example"},{"location":"arduino/classes/#loadcell","text":"","title":"Loadcell"},{"location":"arduino/classes/#overview_1","text":"The arduino will make use of a loadcell to determine the percentage of liquids left in the tank.","title":"Overview"},{"location":"arduino/classes/#hightorqueservoint-minangle-int-maxangle_1","text":"Description: Creates an instance of the High Torque Servo class with specified angle limits. Parameters: doutPin : pin used for digital output (desired: Digital pin 2). sckPin : pin used for sck (desired: Digital pin 3). Example: #include \"Scale.h\" // Constructor: Initializes the Scale object with specified pins and calibration factor Scale::Scale(int doutPin, int sckPin) : doutPin(doutPin), sckPin(sckPin) { }","title":"HighTorqueServo(int minAngle, int maxAngle)"},{"location":"arduino/classes/#methods_1","text":"","title":"Methods"},{"location":"arduino/classes/#void-scaleinit","text":"Sets up the scale and runs the reset function once to calibrate the scale to 0. The scale factor is also applied here.","title":"void Scale::init()"},{"location":"arduino/classes/#void-scalereset","text":"Uses the built in tare function to recalibrate the scale to 0.","title":"void Scale::reset()"},{"location":"arduino/classes/#float-scalegetweight","text":"Returns the current weight of the tank in grams. Returns: float - The current weight of the tank.","title":"float Scale::getWeight()"},{"location":"arduino/classes/#int-scalegetpercentage","text":"Returns the current percentage of liquids in the tank. Returns: int - The current percentage.","title":"int Scale::getPercentage()"},{"location":"arduino/classes/#usage-example_1","text":"#include \"Scale.h\" #include <Wire.h> const int LOADCELL_DOUT_PIN = 2; const int LOADCELL_SCK_PIN = 3; // Create a scale instance Scale scale(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN); void setup() { scale.init(); // initializes the scale } void loop() { int currentState = stateMachine.getState(); // Get the current state int percentage = scale.getPercentage(); // Get the percentage of the tank. }","title":"Usage Example"},{"location":"arduino/installation/","text":"Arduino Installation In this project, the Arduino controlls the servo's, weight sensor and pump. The required installation will be described here. Fetching the Git Project The following commands are ran in Git Bash: mkdir ~/Git && cd ~/Git git clone -b main https://github.com/vrijtap/arduino-uno.git The Git repository should now be located in C:\\Users\\User\\Git General Arduino To install the Arduino, you'll have to download the installation online. After installing the environment, you should follow the circuit documentation to create the circuits required to make this project work. After that, you can plug the arduino into your laptop and the Arduino IDE will automatically detect the USB port associated with an Arduino connected to it. Uploading Project Under 'files', select 'open'. Find the 'arduino-uno/' folder on your machine that you've cloned with Git and open 'arduino-uno.ino'. Finally click on the publish button in the Arduino IDE after selecting the COM port associated with 'Arduino Uno'. Packages Scale HX711 Arduino library","title":"Installation"},{"location":"arduino/installation/#arduino-installation","text":"In this project, the Arduino controlls the servo's, weight sensor and pump. The required installation will be described here.","title":"Arduino Installation"},{"location":"arduino/installation/#fetching-the-git-project","text":"The following commands are ran in Git Bash: mkdir ~/Git && cd ~/Git git clone -b main https://github.com/vrijtap/arduino-uno.git The Git repository should now be located in C:\\Users\\User\\Git","title":"Fetching the Git Project"},{"location":"arduino/installation/#general-arduino","text":"To install the Arduino, you'll have to download the installation online. After installing the environment, you should follow the circuit documentation to create the circuits required to make this project work. After that, you can plug the arduino into your laptop and the Arduino IDE will automatically detect the USB port associated with an Arduino connected to it.","title":"General Arduino"},{"location":"arduino/installation/#uploading-project","text":"Under 'files', select 'open'. Find the 'arduino-uno/' folder on your machine that you've cloned with Git and open 'arduino-uno.ino'. Finally click on the publish button in the Arduino IDE after selecting the COM port associated with 'Arduino Uno'.","title":"Uploading Project"},{"location":"arduino/installation/#packages","text":"","title":"Packages"},{"location":"arduino/installation/#scale","text":"HX711 Arduino library","title":"Scale"},{"location":"artificial-intelligence/model/","text":"Artificial Intelligence Model To solve the issue of detecting when it is okay to pour water/beer in the cup, we decided to create a machine learning model that does binary classification to decide if it is safe to tap. Model As seen in the code cell below, the model created takes an input shape of 64 by 64 with a color depth of 3. This means that all of the input from the camera should be formatted in this exact way before performing the binary classification. The first step in this model is to perform two layers of 2D convolution and max pooling. This is done for the sake of feature selection. After that, the layers are flattened and processed by a dense neural network, which calculates the chance of the picture containing image data of the machine being ready to tap. The dense neural network contains weights that have been fitted to training data, which allows it to detect wether the picture should be classified as a 0 or 1 depending on the previously fed training images. # The model in python model = tf.keras.Sequential([ tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3)), tf.keras.layers.MaxPooling2D((2, 2)), tf.keras.layers.Conv2D(64, (3, 3), activation='relu'), tf.keras.layers.MaxPooling2D((2, 2)), tf.keras.layers.Flatten(), tf.keras.layers.Dense(128, activation='relu'), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(1, activation='sigmoid') ]) Performance As for now, we don't have a good testing prototype, so the images the model has been fitted to are unusable in the future. Creating a correct dataset should be the first priority after a prototype with the Raspberry Pi Camera and Cup Holder functions correctly. For now, the performance with 30 palceholder test images is: Usage To use this model, you simply copy the .h5 model output (saved model information/weights) and you replace the one that's in the raspberry-pi repository. After correcting the model path in the main.py, you should now be able to use the model trained using the python notebook.","title":"Model"},{"location":"artificial-intelligence/model/#artificial-intelligence-model","text":"To solve the issue of detecting when it is okay to pour water/beer in the cup, we decided to create a machine learning model that does binary classification to decide if it is safe to tap.","title":"Artificial Intelligence Model"},{"location":"artificial-intelligence/model/#model","text":"As seen in the code cell below, the model created takes an input shape of 64 by 64 with a color depth of 3. This means that all of the input from the camera should be formatted in this exact way before performing the binary classification. The first step in this model is to perform two layers of 2D convolution and max pooling. This is done for the sake of feature selection. After that, the layers are flattened and processed by a dense neural network, which calculates the chance of the picture containing image data of the machine being ready to tap. The dense neural network contains weights that have been fitted to training data, which allows it to detect wether the picture should be classified as a 0 or 1 depending on the previously fed training images. # The model in python model = tf.keras.Sequential([ tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3)), tf.keras.layers.MaxPooling2D((2, 2)), tf.keras.layers.Conv2D(64, (3, 3), activation='relu'), tf.keras.layers.MaxPooling2D((2, 2)), tf.keras.layers.Flatten(), tf.keras.layers.Dense(128, activation='relu'), tf.keras.layers.Dropout(0.5), tf.keras.layers.Dense(1, activation='sigmoid') ])","title":"Model"},{"location":"artificial-intelligence/model/#performance","text":"As for now, we don't have a good testing prototype, so the images the model has been fitted to are unusable in the future. Creating a correct dataset should be the first priority after a prototype with the Raspberry Pi Camera and Cup Holder functions correctly. For now, the performance with 30 palceholder test images is:","title":"Performance"},{"location":"artificial-intelligence/model/#usage","text":"To use this model, you simply copy the .h5 model output (saved model information/weights) and you replace the one that's in the raspberry-pi repository. After correcting the model path in the main.py, you should now be able to use the model trained using the python notebook.","title":"Usage"},{"location":"raspberry-pi/circuit/","text":"Raspberry Pi Circuit In this project, the Raspberry Pi only controlls the RFID scanner and a preasure sensor for creating an interrupt. The circuit will be described in this file. The Rfid reader The project uses an RFID reader to read the user cards, this reader is connected via a set of wires which are connected as seen in the image below: This sensor runs on 3.3V supplied by the connected RaspberryPi. The I2C connection The project uses two wires to communicate with the arduino uno, this is done via the I2C protocol. These two wires are connected to the SDA and SCL ports. Note: The Arduino and the RaspberryPi need to be connected to the same power source to enable the I2C connection, hence why it is connected via the VCC directly from the Pi. Howerver this is also possible by powering the arduino via usb from the Pi.","title":"Circuit"},{"location":"raspberry-pi/circuit/#raspberry-pi-circuit","text":"In this project, the Raspberry Pi only controlls the RFID scanner and a preasure sensor for creating an interrupt. The circuit will be described in this file.","title":"Raspberry Pi Circuit"},{"location":"raspberry-pi/circuit/#the-rfid-reader","text":"The project uses an RFID reader to read the user cards, this reader is connected via a set of wires which are connected as seen in the image below: This sensor runs on 3.3V supplied by the connected RaspberryPi.","title":"The Rfid reader"},{"location":"raspberry-pi/circuit/#the-i2c-connection","text":"The project uses two wires to communicate with the arduino uno, this is done via the I2C protocol. These two wires are connected to the SDA and SCL ports. Note: The Arduino and the RaspberryPi need to be connected to the same power source to enable the I2C connection, hence why it is connected via the VCC directly from the Pi. Howerver this is also possible by powering the arduino via usb from the Pi.","title":"The I2C connection"},{"location":"raspberry-pi/classes/","text":"RaspberryPi Classes In this file, all of the classes made for the RaspberryPi 4B+ are generally discribed in their use and initialisation. Disclaimer: Once the libraries have been initialized you can use the functions included within them. cameraLib The camera library enables the camera by using the picam2 module. camera.Camera(picture_size) Description: Creates an instance of the camera class with specified size. Parameters: picture_size : The height and width size of the picture (accepted value: [64]). Example: from cameraLib import camera cam = camera.Camera(64) cam.burst(path, name, amount, seconds) Description: The burst function creates a set of images seperated by a given time. The images will be saved as .jpg. Parameters: path : The location where the images should be saved at. name : The name of the images. Is set per image and will be wrapped by datatime data. amount : The amount of pictures to be taken. seconds : The timing in between pictures being taken. Example: cam.burst(\"~/path_to_image_folder\", \"image_name\", 30, 1) cam.capture(path, name) Description: The capture function creates a single image and saves it, as a .jpg, to a given location. Parameters: path : The location where the images should be saved at. name : The name of the images. Is set per image. Is set per image and will be wrapped by datatime data. Example: cam.capture(\"~/path_to_image_folder\", \"image_name\") cam.captureArray() Description: The captureArray function creates an array wherein the imagedata is saved. It will return this array. Example: image_array = cam.captureArray() i2cLib The I2C library enables the device to use the I2C communication channel in a simple fashion. It uses the smbus2 module. bus.Bus(port, adress) Description: Creates an instance of the i2c class with specified adress and port. Parameters: port : The port the I2C connection is set up from (Default: [1]). adress : The height and width size of the picture (Default: [0x8]). Example: from i2cLib import bus i2c = bus.Bus(1, 0x8) bus.send_data(data) Description: The send_data function will send out the handed data. Given that it is an integer and within one byte. Parameters: data : This can be any int value as long as it is in one byte. Otherwise it will restart again from 0. (Recommended range: [0, 255]). Example: i2c.send_data(32) bus.receive_data() Description: The receive_data function will poll the slave for any changes on the I2C bus. it will receive what the value on the slave currently is. Example: polled_message = i2c.receive_data() bus.send_and_check(data) Description: The send_and_check function will send out a message to the slave and requires the slave to echo the same message back, this is done to know for sure the message has been delivered to the slave. This function also returns a True or False depending on if the message was delivered succesfully. Parameters: data : This can be any int value as long as it is in one byte. Otherwise it will restart again from 0. (Recommended range: [0, 255]). Example: if i2c.send_and_check(1): #do something here RFIDLib The Rfid library enables the device to use the rfid-rc522 device. It uses the modules RPi.GPIO and mfrc522. readerRFID.Rfid() Description: Creates an instance of the rfid class. Example: from rfidLib import readerRFID rfid = readerRFID.Rfid() rfid.write(data) Description: The rfid_write function will write the given data to an rfid writable object, eg. myfairclassic cards. This function is only to write without much checks being in place. It will give an exception if the write process has failed. Parameters: data : This can be anything, preferably a string. Example: rfid.write(string_of_words) rfid.read() Description: The read function will enable the rfid module to read data from any carrying rfid object in range of the reader. It will read what has been written to the medium and it will perform a check to see if it is the correct size of 48. This size is chosen based upon the lenght of the MongoDB ID size. This function will return the read data. Example: data_on_card = rfid.read() rfid.closeGPIO() Description: This function has to be called at the end of the whole program to reset the GPIO usage on the RaspberryPi. Example: # End of program, shutting down. rfid.closeGPIO() MongoLib The mongo library enables the device to use the mongodb functions in a simple fashion. It uses the modules pymongo, bson, pymongo.errors and bson.errors. mdb = mongo.Mongo(uri, database_name, collection_name) Description: Creates an instance of the mongo library class. Will connect to a mongo database using the variables given. The function will also give an exception if setting up the connection takes longer than 30 seconds. Parameters: uri : This should be a URI value to connect to a database. database_name : This should be the name of the database. collection_name : This should be the name of the collection. Example: from mongoLib import mongo mdb = mongo.Mongo(uri, 'backend', 'cards') mdb.userExists(uid: str) Description: The userExists function will look in the database if there is a user with the ID supplied to the function. It will return a True or False based upon the results found. If the user exists this function will also aquire the data about how many drinks there are left for this user. If there is an invalid user ID supplied to the function it will return a False and notify that the type of data is the wrong format. Parameters: uid : The ID of the user you are trying to find. This must be a string. Example: if mdb.userExists(uid) == True: # Do something mdb.decreaseBeer() Description: This function will check if the user still has their \"beers\" value in the positives. If not, there wont be a reduction in this value on the database. If there is a positive balance, there will be an increase of -1 to the database value \"beers\". This function will return False if a wrong uid is given to the mdb.userExists(uid) function. Example: mdb.decreaseBeer() mdb.closeConnection() Description: This function will close the database connection. Example: # End of program, shutting down. mdb.closeConnection()","title":"Libraries"},{"location":"raspberry-pi/classes/#raspberrypi-classes","text":"In this file, all of the classes made for the RaspberryPi 4B+ are generally discribed in their use and initialisation. Disclaimer: Once the libraries have been initialized you can use the functions included within them.","title":"RaspberryPi Classes"},{"location":"raspberry-pi/classes/#cameralib","text":"The camera library enables the camera by using the picam2 module.","title":"cameraLib"},{"location":"raspberry-pi/classes/#cameracamerapicture_size","text":"Description: Creates an instance of the camera class with specified size. Parameters: picture_size : The height and width size of the picture (accepted value: [64]). Example: from cameraLib import camera cam = camera.Camera(64)","title":"camera.Camera(picture_size)"},{"location":"raspberry-pi/classes/#camburstpath-name-amount-seconds","text":"Description: The burst function creates a set of images seperated by a given time. The images will be saved as .jpg. Parameters: path : The location where the images should be saved at. name : The name of the images. Is set per image and will be wrapped by datatime data. amount : The amount of pictures to be taken. seconds : The timing in between pictures being taken. Example: cam.burst(\"~/path_to_image_folder\", \"image_name\", 30, 1)","title":"cam.burst(path, name, amount, seconds)"},{"location":"raspberry-pi/classes/#camcapturepath-name","text":"Description: The capture function creates a single image and saves it, as a .jpg, to a given location. Parameters: path : The location where the images should be saved at. name : The name of the images. Is set per image. Is set per image and will be wrapped by datatime data. Example: cam.capture(\"~/path_to_image_folder\", \"image_name\")","title":"cam.capture(path, name)"},{"location":"raspberry-pi/classes/#camcapturearray","text":"Description: The captureArray function creates an array wherein the imagedata is saved. It will return this array. Example: image_array = cam.captureArray()","title":"cam.captureArray()"},{"location":"raspberry-pi/classes/#i2clib","text":"The I2C library enables the device to use the I2C communication channel in a simple fashion. It uses the smbus2 module.","title":"i2cLib"},{"location":"raspberry-pi/classes/#busbusport-adress","text":"Description: Creates an instance of the i2c class with specified adress and port. Parameters: port : The port the I2C connection is set up from (Default: [1]). adress : The height and width size of the picture (Default: [0x8]). Example: from i2cLib import bus i2c = bus.Bus(1, 0x8)","title":"bus.Bus(port, adress)"},{"location":"raspberry-pi/classes/#bussend_datadata","text":"Description: The send_data function will send out the handed data. Given that it is an integer and within one byte. Parameters: data : This can be any int value as long as it is in one byte. Otherwise it will restart again from 0. (Recommended range: [0, 255]). Example: i2c.send_data(32)","title":"bus.send_data(data)"},{"location":"raspberry-pi/classes/#busreceive_data","text":"Description: The receive_data function will poll the slave for any changes on the I2C bus. it will receive what the value on the slave currently is. Example: polled_message = i2c.receive_data()","title":"bus.receive_data()"},{"location":"raspberry-pi/classes/#bussend_and_checkdata","text":"Description: The send_and_check function will send out a message to the slave and requires the slave to echo the same message back, this is done to know for sure the message has been delivered to the slave. This function also returns a True or False depending on if the message was delivered succesfully. Parameters: data : This can be any int value as long as it is in one byte. Otherwise it will restart again from 0. (Recommended range: [0, 255]). Example: if i2c.send_and_check(1): #do something here","title":"bus.send_and_check(data)"},{"location":"raspberry-pi/classes/#rfidlib","text":"The Rfid library enables the device to use the rfid-rc522 device. It uses the modules RPi.GPIO and mfrc522.","title":"RFIDLib"},{"location":"raspberry-pi/classes/#readerrfidrfid","text":"Description: Creates an instance of the rfid class. Example: from rfidLib import readerRFID rfid = readerRFID.Rfid()","title":"readerRFID.Rfid()"},{"location":"raspberry-pi/classes/#rfidwritedata","text":"Description: The rfid_write function will write the given data to an rfid writable object, eg. myfairclassic cards. This function is only to write without much checks being in place. It will give an exception if the write process has failed. Parameters: data : This can be anything, preferably a string. Example: rfid.write(string_of_words)","title":"rfid.write(data)"},{"location":"raspberry-pi/classes/#rfidread","text":"Description: The read function will enable the rfid module to read data from any carrying rfid object in range of the reader. It will read what has been written to the medium and it will perform a check to see if it is the correct size of 48. This size is chosen based upon the lenght of the MongoDB ID size. This function will return the read data. Example: data_on_card = rfid.read()","title":"rfid.read()"},{"location":"raspberry-pi/classes/#rfidclosegpio","text":"Description: This function has to be called at the end of the whole program to reset the GPIO usage on the RaspberryPi. Example: # End of program, shutting down. rfid.closeGPIO()","title":"rfid.closeGPIO()"},{"location":"raspberry-pi/classes/#mongolib","text":"The mongo library enables the device to use the mongodb functions in a simple fashion. It uses the modules pymongo, bson, pymongo.errors and bson.errors.","title":"MongoLib"},{"location":"raspberry-pi/classes/#mdb-mongomongouri-database_name-collection_name","text":"Description: Creates an instance of the mongo library class. Will connect to a mongo database using the variables given. The function will also give an exception if setting up the connection takes longer than 30 seconds. Parameters: uri : This should be a URI value to connect to a database. database_name : This should be the name of the database. collection_name : This should be the name of the collection. Example: from mongoLib import mongo mdb = mongo.Mongo(uri, 'backend', 'cards')","title":"mdb = mongo.Mongo(uri, database_name, collection_name)"},{"location":"raspberry-pi/classes/#mdbuserexistsuid-str","text":"Description: The userExists function will look in the database if there is a user with the ID supplied to the function. It will return a True or False based upon the results found. If the user exists this function will also aquire the data about how many drinks there are left for this user. If there is an invalid user ID supplied to the function it will return a False and notify that the type of data is the wrong format. Parameters: uid : The ID of the user you are trying to find. This must be a string. Example: if mdb.userExists(uid) == True: # Do something","title":"mdb.userExists(uid: str)"},{"location":"raspberry-pi/classes/#mdbdecreasebeer","text":"Description: This function will check if the user still has their \"beers\" value in the positives. If not, there wont be a reduction in this value on the database. If there is a positive balance, there will be an increase of -1 to the database value \"beers\". This function will return False if a wrong uid is given to the mdb.userExists(uid) function. Example: mdb.decreaseBeer()","title":"mdb.decreaseBeer()"},{"location":"raspberry-pi/classes/#mdbcloseconnection","text":"Description: This function will close the database connection. Example: # End of program, shutting down. mdb.closeConnection()","title":"mdb.closeConnection()"},{"location":"raspberry-pi/installation/","text":"Raspberry Pi Installation Due to the Raspberry Pi being an operating system running the server, AI and a couple of sensors, there is a bunch of installations to be done before the pi can operate within the project. The operating system you need to install is a 64-bit headless raspbian installation with access to your wireless network and an open SSH port. Git Installation on a fresh Pi Ofcourse we need to install Git, as our project is based on Github. Clone the project sudo apt update sudo apt upgrade sudo apt install git git clone https://github.com/vrijtap/raspberry-pi.git cd raspberry-pi ls Camera Installation To enable the camera on the RaspberryPi you will need to turn the legacy camera on in the config screen, you can do this by running the command: sudo raspi-config Here you should select the Interface options and turn on the legacy camera support. After this you can close this screen and reboot the pi. Next up you should edit the config.txt and you should add two lines to make the camera detectable. sudo nano /boot/config.txt #Add two lines to the end of the file dtoverlay=imx219 camera_auto_detect=0 RFID Module Installation To enable the RFID-RC522 module you will need to connect it to the RaspberryPi as shown in the images in the Circuit page. Now you can boot up the RaspberryPi and go to the configuration screen. sudo raspi-config Here you should enable the SPI setting in Interface options and reboot the Pi. Now the Pi has enabled the SPI inteface and now you can install spidev and the module needed for the RFID module: sudo pip3 install --upgrade spidev sudo pip3 install mfrc522 Now the Pi should be able to use the RFID library functions. I2C Module Installation To enable the I2C functions you should again head to the configuration screen: sudo raspi-config Head to the interface options and enable I2C there. After this you should reboot the Pi. After booting the pi up again you should install the smbus2 packages to make the I2C library function. pip install smbus2 MongoDB Package Installation To use the functions in the mongo library included in the project you should install some packages for it to work. python3 -m pip install pymongo pip install bson After installing these packages you should be able to use the functions in the Mongo Library.","title":"Installation"},{"location":"raspberry-pi/installation/#raspberry-pi-installation","text":"Due to the Raspberry Pi being an operating system running the server, AI and a couple of sensors, there is a bunch of installations to be done before the pi can operate within the project. The operating system you need to install is a 64-bit headless raspbian installation with access to your wireless network and an open SSH port.","title":"Raspberry Pi Installation"},{"location":"raspberry-pi/installation/#git-installation-on-a-fresh-pi","text":"Ofcourse we need to install Git, as our project is based on Github. Clone the project sudo apt update sudo apt upgrade sudo apt install git git clone https://github.com/vrijtap/raspberry-pi.git cd raspberry-pi ls","title":"Git Installation on a fresh Pi"},{"location":"raspberry-pi/installation/#camera-installation","text":"To enable the camera on the RaspberryPi you will need to turn the legacy camera on in the config screen, you can do this by running the command: sudo raspi-config Here you should select the Interface options and turn on the legacy camera support. After this you can close this screen and reboot the pi. Next up you should edit the config.txt and you should add two lines to make the camera detectable. sudo nano /boot/config.txt #Add two lines to the end of the file dtoverlay=imx219 camera_auto_detect=0","title":"Camera Installation"},{"location":"raspberry-pi/installation/#rfid-module-installation","text":"To enable the RFID-RC522 module you will need to connect it to the RaspberryPi as shown in the images in the Circuit page. Now you can boot up the RaspberryPi and go to the configuration screen. sudo raspi-config Here you should enable the SPI setting in Interface options and reboot the Pi. Now the Pi has enabled the SPI inteface and now you can install spidev and the module needed for the RFID module: sudo pip3 install --upgrade spidev sudo pip3 install mfrc522 Now the Pi should be able to use the RFID library functions.","title":"RFID Module Installation"},{"location":"raspberry-pi/installation/#i2c-module-installation","text":"To enable the I2C functions you should again head to the configuration screen: sudo raspi-config Head to the interface options and enable I2C there. After this you should reboot the Pi. After booting the pi up again you should install the smbus2 packages to make the I2C library function. pip install smbus2","title":"I2C Module Installation"},{"location":"raspberry-pi/installation/#mongodb-package-installation","text":"To use the functions in the mongo library included in the project you should install some packages for it to work. python3 -m pip install pymongo pip install bson After installing these packages you should be able to use the functions in the Mongo Library.","title":"MongoDB Package Installation"},{"location":"website/installation/","text":"Installation This page contains the entire installation of the website and what is needed to run the website in its current state. If the installation guide does not perform as expected, you could try to use a newer version. This installation is specifically targeted towards the Raspberry Pi 3. Installing Prerequisites sudo apt update sudo apt upgrade sudo apt install git Installing Go Fetch, install and delete the Installation Files. wget https://go.dev/dl/go1.21.4.linux-arm64.tar.gz sudo tar -C /usr/local -xzf go1.21.4.linux-arm64.tar.gz rm go1.21.4.linux-arm64.tar.gz Enter the profile config to configure the GO path. nano ~/.profile # Add to the bottom of the file and save (with CTRL+X and then select Y): PATH=$PATH:/usr/local/go/bin GOPATH=$HOME/go Refresh the .profile file and check if go was installed succesfully. source ~/.profile go version Fetching the dev-payment-gate cd ~/ git clone https://github.com/vrijtap/dev-payment-gate.git cd ~/dev-payment-gate Fetching the website Repository cd ~/ git clone https://github.com/vrijtap/website.git cd ~/website Run dev-payment-gate (development) When you are running a development instance of the website, you might want to use our fake payment server to simulate purchases. To do this, you can copy '.env.template' as '.env' and fill in all of the information requested. cd ~/dev-payment-gate cp .env.template .env nano .env Here is how you can set it up: # Server Communication MONGO_URI= # [The key to your personal mongodb environment] # HTTP Information PORT=\"9090\" # API key for using this server API_KEY=\"dev-payment-gate-key\" The command underneath starts the payment gate locally. cd ~/dev-payment-gate go run cmd/main.go Run website After installing all of the prerequisites and go and fetching the github repository, you can copy '.env.template' as '.env' and fill in all of the information requested. cd ~/website cp .env.template .env nano .env Here is how you can set it up for development: # Environment ENVIRONMENT=\"development\" # HTTP Information (development) PORT_HTTP=\"8080\" # HTTPS Information (production) PORT_HTTPS=\"4443\" PATH_CERT_FILE= PATH_KEY_FILE= # Server Communication MONGO_URI= # [The key to your personal mongodb environment] # Server Secrets SERVER_SECRET=\"secret\" PASSWORD_DEFAULT=\"default\" # Payment Gate Information PAYMENT_GATE_URL=\"http://raspberry:9090/transaction\" PAYMENT_GATE_KEY=\"dev-payment-gate-key\" WEBHOOK_KEY=\"website-webhook-key\" # Information NAME=\"Test Bar\" PRICE=\"2.95\" The command underneath starts the website locally. cd ~/website go run cmd/main.go","title":"Installation"},{"location":"website/installation/#installation","text":"This page contains the entire installation of the website and what is needed to run the website in its current state. If the installation guide does not perform as expected, you could try to use a newer version. This installation is specifically targeted towards the Raspberry Pi 3.","title":"Installation"},{"location":"website/installation/#installing-prerequisites","text":"sudo apt update sudo apt upgrade sudo apt install git","title":"Installing Prerequisites"},{"location":"website/installation/#installing-go","text":"Fetch, install and delete the Installation Files. wget https://go.dev/dl/go1.21.4.linux-arm64.tar.gz sudo tar -C /usr/local -xzf go1.21.4.linux-arm64.tar.gz rm go1.21.4.linux-arm64.tar.gz Enter the profile config to configure the GO path. nano ~/.profile # Add to the bottom of the file and save (with CTRL+X and then select Y): PATH=$PATH:/usr/local/go/bin GOPATH=$HOME/go Refresh the .profile file and check if go was installed succesfully. source ~/.profile go version","title":"Installing Go"},{"location":"website/installation/#fetching-the-dev-payment-gate","text":"cd ~/ git clone https://github.com/vrijtap/dev-payment-gate.git cd ~/dev-payment-gate","title":"Fetching the dev-payment-gate"},{"location":"website/installation/#fetching-the-website-repository","text":"cd ~/ git clone https://github.com/vrijtap/website.git cd ~/website","title":"Fetching the website Repository"},{"location":"website/installation/#run-dev-payment-gate-development","text":"When you are running a development instance of the website, you might want to use our fake payment server to simulate purchases. To do this, you can copy '.env.template' as '.env' and fill in all of the information requested. cd ~/dev-payment-gate cp .env.template .env nano .env Here is how you can set it up: # Server Communication MONGO_URI= # [The key to your personal mongodb environment] # HTTP Information PORT=\"9090\" # API key for using this server API_KEY=\"dev-payment-gate-key\" The command underneath starts the payment gate locally. cd ~/dev-payment-gate go run cmd/main.go","title":"Run dev-payment-gate (development)"},{"location":"website/installation/#run-website","text":"After installing all of the prerequisites and go and fetching the github repository, you can copy '.env.template' as '.env' and fill in all of the information requested. cd ~/website cp .env.template .env nano .env Here is how you can set it up for development: # Environment ENVIRONMENT=\"development\" # HTTP Information (development) PORT_HTTP=\"8080\" # HTTPS Information (production) PORT_HTTPS=\"4443\" PATH_CERT_FILE= PATH_KEY_FILE= # Server Communication MONGO_URI= # [The key to your personal mongodb environment] # Server Secrets SERVER_SECRET=\"secret\" PASSWORD_DEFAULT=\"default\" # Payment Gate Information PAYMENT_GATE_URL=\"http://raspberry:9090/transaction\" PAYMENT_GATE_KEY=\"dev-payment-gate-key\" WEBHOOK_KEY=\"website-webhook-key\" # Information NAME=\"Test Bar\" PRICE=\"2.95\" The command underneath starts the website locally. cd ~/website go run cmd/main.go","title":"Run website"}]}